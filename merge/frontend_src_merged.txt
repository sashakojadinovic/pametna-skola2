// File: /var/www/html/pametna-skola2/frontend/src/components/Admin/RingRow.jsx
/**
 * File: RingRow.jsx
 * Path: /frontend/src/components/Admin
 * Author: Sa≈°a Kojadinoviƒá
 */

import { Stack, TextField, IconButton, Tooltip } from "@mui/material";
import DeleteIcon from "@mui/icons-material/Delete";
import { TimePicker } from "@mui/x-date-pickers";
import dayjs from "dayjs";
import customParseFormat from "dayjs/plugin/customParseFormat";
dayjs.extend(customParseFormat);

// "HH:MM" -> Dayjs | null
function hhmmToDayjs(hhmm) {
  if (!/^\d{2}:\d{2}$/.test(hhmm || "")) return null;
  const [h, m] = hhmm.split(":").map(Number);
  return dayjs().hour(h).minute(m).second(0).millisecond(0);
}

export default function RingRow({ value, onChange, onDelete, error }) {
  const { time = "", label = "" } = value || {};
  const timeObj = hhmmToDayjs(time);

  return (
    <Stack direction={{ xs: "column", sm: "row" }} spacing={1} alignItems="center">
      <TimePicker
        label="–í—Ä–µ–º–µ"
        ampm={false}                 // ‚¨ÖÔ∏è forsira 24h
        format="HH:mm"               // ‚¨ÖÔ∏è prikaz i parsing
        views={["hours", "minutes"]}
        minutesStep={1}
        value={timeObj}
        onChange={(val) => {
          const next = val && val.isValid() ? val.format("HH:mm") : "";
          onChange?.({ ...value, time: next });
        }}
        // Stil i error na ugraƒëenom TextField-u:
        slotProps={{
          textField: {
            sx: { width: 160 },
            error: Boolean(error),
            helperText: error ? "–§–æ—Ä–º–∞—Ç HH:MM" : " ",
            InputLabelProps: { shrink: true },
          },
        }}
      />

      <TextField
       sx={{bottom:'11px'}}
        label="–û–ø–∏—Å"
        value={label}
        onChange={(e) => onChange?.({ ...value, label: e.target.value })}
        fullWidth
      />

      <Tooltip title="–û–±—Ä–∏—à–∏ –∑–≤–æ–Ω–æ">
        <IconButton  onClick={onDelete}>
          <DeleteIcon />
        </IconButton>
      </Tooltip>
    </Stack>
  );
}


// File: /var/www/html/pametna-skola2/frontend/src/components/Admin/TemplateSelect.jsx
/**
 * File: TemplateSelect.jsx
 * Path: /frontend/src/components/Admin
 * Author: Sa≈°a Kojadinoviƒá
 */

import { useEffect, useMemo, useState } from "react";
import { Autocomplete, TextField, CircularProgress, Box } from "@mui/material";
import bellApi from "../../api/bellApi";
import ColorDot from "./ColorDot";

export default function TemplateSelect({ value, onChange, label = "–®–∞–±–ª–æ–Ω" }) {
  const [loading, setLoading] = useState(true);
  const [templates, setTemplates] = useState([]);

  useEffect(() => {
    let mounted = true;
    (async () => {
      setLoading(true);
      try {
        const data = await bellApi.getTemplates();
        if (mounted) setTemplates(Array.isArray(data) ? data : []);
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => { mounted = false; };
  }, []);

  const selected = useMemo(
    () => templates.find((t) => t.id === value) || null,
    [templates, value]
  );
  console.log(templates);
  return (
    <Autocomplete
      options={templates}
      getOptionLabel={(o) => o?.name || ""}
      value={selected}
      onChange={(_, opt) => onChange?.(opt ? opt.id : null)}
      loading={loading}
      renderInput={(params) => (
        <TextField
        variant="standard"
        sx={{mb:1}}
          {...params}
          label={label}
          InputProps={{
            ...params.InputProps,
            endAdornment: (
              <>
                {loading ? <CircularProgress size={18} /> : null}
                {params.InputProps.endAdornment}
              </>
            ),
          }}
        />
      )}
      renderOption={(props, option) => (
        <Box component="li" {...props}>
          <ColorDot color={option.color || "#1976d2"} />
          {option.name}
        </Box>
      )}
      isOptionEqualToValue={(a, b) => a?.id === b?.id}
    />
  );
}


// File: /var/www/html/pametna-skola2/frontend/src/components/DisplayBoard/AnnouncementBoard.jsx
/**
 * File: AnnouncementBoard.jsx
 * Path: /src/components/DisplayBoard/AnnouncementBoard.jsx
 * Author: Sa≈°a Kojadinoviƒá
 */

import { useEffect, useMemo, useState } from "react";
import { Typography, Box, Alert, Fade } from "@mui/material";
import DOMPurify from "dompurify";

const priorityAccent = {
  NORMAL: "info.main",
  HIGH: "warning.main",
  URGENT: "error.main",
};

export default function CarouselAnnouncementBoard({ items = [], override = null }) {
  const [index, setIndex] = useState(0);
  const [fadeIn, setFadeIn] = useState(true);

  const visibleItem = useMemo(() => {
    if (!items.length) return null;
    return items[index % items.length];
  }, [items, index]);

  // Dinamiƒçko trajanje slajda prema du≈æini teksta
  const currentDuration = useMemo(() => {
    if (!visibleItem) return 10000;
    const textLen = (visibleItem.title?.length || 0) + (visibleItem.body?.length || 0);
    const extra = Math.min(12000, Math.ceil(textLen / 90) * 1000); // +1s na ~90 karaktera
    return 8000 + extra; // 8s baza
  }, [visibleItem]);

  // Automatska rotacija ‚Äî pauziraj kada postoji override
  useEffect(() => {
    if (!items.length || override) return;
    const id = setInterval(() => {
      setFadeIn(false);
      setTimeout(() => {
        setIndex((i) => (i + 1) % items.length);
        setFadeIn(true);
      }, 350);
    }, currentDuration);
    return () => clearInterval(id);
  }, [items, override, currentDuration]);

  if (!items.length && !override) return null;

  return (
    <Box sx={{ width: "100%" }}>
      {/* Push –æ–±–∞–≤–µ—à—Ç–µ—ö–µ (override) */}
      <Fade in={Boolean(override)} mountOnEnter unmountOnExit>
        <Alert
          severity="info"
          icon={false}
          sx={{
            fontSize: "clamp(20px, 3.6vw, 42px)",
            fontWeight: 800,
            px: 2,
            py: 1.5,
            borderLeft: 0,
            bgcolor: "action.hover",
          }}
        >
          üì¢ {override?.title ? `${override.title}: ` : ""}
          <span dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(override?.body || "") }} />
        </Alert>
      </Fade>

      {/* Carousel prikaz ‚Äî radi —Å–∞–º–æ –∫–∞–¥ –Ω–µ–º–∞ override */}
      {!override && visibleItem && (
        <Fade in={fadeIn} timeout={400}>
          <Box
            key={visibleItem.id}
            sx={{
              px: 2,
              py: 1.5,
              borderLeft: (t) => `8px solid ${t.palette[priorityAccentKey(visibleItem.priority)].main}`,
              bgcolor: "transparent",
              minHeight: 140,
            }}
          >
            <Typography variant="h2" sx={{ fontSize: "clamp(24px, 4.8vw, 56px)", fontWeight: 800, mb: 0.5 }}>
              {visibleItem.title}
            </Typography>
            {visibleItem.body && (
              <Typography
                component="div"
                sx={{ fontSize: "clamp(16px, 2.6vw, 28px)", lineHeight: 1.25, opacity: 0.95 }}
                dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(visibleItem.body) }}
              />
            )}

            {/* Page dots */}
            {items.length > 1 && (
              <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
                {items.map((_, i) => (
                  <Box
                    key={i}
                    sx={{
                      width: 10,
                      height: 10,
                      borderRadius: "50%",
                      opacity: i === index ? 1 : 0.35,
                      bgcolor: (t) => t.palette[priorityAccentKey(visibleItem.priority)].main,
                    }}
                  />
                ))}
              </Box>
            )}
          </Box>
        </Fade>
      )}
    </Box>
  );
}

function priorityAccentKey(priority) {
  if (priority === "URGENT") return "error";
  if (priority === "HIGH") return "warning";
  return "info";
}


// File: /var/www/html/pametna-skola2/frontend/src/components/DisplayBoard/CarouselAnnouncementBoard.jsx
/**
 * File: CarouselAnnouncementBoard.jsx
 * Path: /frontend/src/components/DisplayBoard
 * Author: Sa≈°a Kojadinoviƒá
 */

import { useEffect, useMemo, useState } from "react";
import {
  Card,
  CardContent,
  Typography,
  Box,
  Alert,
  Fade,
} from "@mui/material";
import DOMPurify from "dompurify";

const priorityColor = {
  NORMAL: "primary",
  HIGH: "warning",
  URGENT: "error",
};

export default function CarouselAnnouncementBoard({ items = [], override = null }) {
  const [index, setIndex] = useState(0);
  const [fadeIn, setFadeIn] = useState(true);

  const visibleItem = useMemo(() => {
    if (!items.length) return null;
    return items[index % items.length];
  }, [items, index]);

  // Automatska rotacija ‚Äî pauziraj kada postoji override
  useEffect(() => {
    if (!items.length || override) return;

    const interval = setInterval(() => {
      setFadeIn(false);
      setTimeout(() => {
        setIndex((i) => (i + 1) % items.length);
        setFadeIn(true);
      }, 400);
    }, 15000);

    return () => clearInterval(interval);
  }, [items, override]);

  if (!items.length && !override) return null;

  return (
    <Box sx={{ mb: 3, minHeight: 220}}>
      {/* Push obave≈°tenje (override) ‚Äî prikazuje se samo dok roditelj prosleƒëuje prop */}
      <Fade in={Boolean(override)} mountOnEnter unmountOnExit>
        <Alert
          severity="info"
          sx={{
            mb: 2,
            fontSize: 30,
            fontWeight: "bold",
            borderLeft: "6px solid",
            borderColor: "info.main",
          }}
        >
          üì¢ –•–∏—Ç–Ω–æ –æ–±–∞–≤–µ—à—Ç–µ—ö–µ:  {override?.body}
        </Alert>
      </Fade>

      {/* Carousel prikaz ‚Äî radi samo kad nema override */}
      {!override && visibleItem && (
        <Fade in={fadeIn} timeout={500}>
          <Box>
            <Card
              key={visibleItem.id}
              sx={{
                borderTop: `6px solid`,
                borderColor: `${priorityColor[visibleItem.priority] || "info"}.main`,
                minHeight: 180,
                backgroundColor: "#efefef" 
              }}
            >
              <CardContent>
                <Typography variant="h3" gutterBottom>
                  {visibleItem.title}
                </Typography>
                {visibleItem.body && (
                  <Typography
                    variant="body1"
                    component="div"
                    dangerouslySetInnerHTML={{
                      __html: DOMPurify.sanitize(visibleItem.body),
                    }}
                  />
                )}
              </CardContent>
            </Card>

            <Typography
              variant="caption"
              color="text.secondary"
              align="center"
              sx={{ mt: 1 }}
            >
              –û–±–∞–≤–µ—à—Ç–µ—ö–µ {index + 1} –æ–¥ {items.length}
            </Typography>
          </Box>
        </Fade>
      )}
    </Box>
  );
}


// File: /var/www/html/pametna-skola2/frontend/src/components/DisplayBoard/DisplayBoard.jsx
/**
 * File: DisplayBoard.jsx
 * Path: /frontend/src/components/DisplayBoard
 * Author: Sa≈°a Kojadinoviƒá
 */

import { useEffect, useMemo, useRef, useState } from "react";
import { io } from "socket.io-client";
import {
  Box,
  Typography,
  Stack,
  Chip,
  IconButton,
  Tooltip,
  CircularProgress,
} from "@mui/material";
import VolumeUpIcon from "@mui/icons-material/VolumeUp";
import VolumeOffIcon from "@mui/icons-material/VolumeOff";
import CloudDoneIcon from "@mui/icons-material/CloudDone";
import CloudOffIcon from "@mui/icons-material/CloudOff";
import RefreshIcon from "@mui/icons-material/Refresh";
import bellApi from "../../api/bellApi";
import CarouselAnnouncementBoard from "./CarouselAnnouncementBoard";
import alertSound from "../../assets/sounds/alert-gentle.mp3";
import {
  buildRings,
  buildSegments,
  formatClock,
  formatMS,
} from "../../utils/bell";
import api from "../../api/axiosInstance"; // ‚úÖ Dodato

// =====================
// Top bar (—Å–∞—Ç + —Å—Ç–∞—Ç—É—Å–∏)
// =====================
function TopBar({ nowTick, connected, audioReady, onUnlock, onSoftRefresh }) {
  const d = new Date(nowTick);
  const hh = String(d.getHours()).padStart(2, "0");
  const mm = String(d.getMinutes()).padStart(2, "0");
  const ss = String(d.getSeconds()).padStart(2, "0");
  const days = [
    "–ù–µ–¥–µ—ô–∞",
    "–ü–æ–Ω–µ–¥–µ—ô–∞–∫",
    "–£—Ç–æ—Ä–∞–∫",
    "–°—Ä–µ–¥–∞",
    "–ß–µ—Ç–≤—Ä—Ç–∞–∫",
    "–ü–µ—Ç–∞–∫",
    "–°—É–±–æ—Ç–∞",
  ];
  return (
    <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ px: 3, py: 1.5, minHeight: 72 }}>
      <Stack direction="row" alignItems="baseline" spacing={2}>
        <Typography component="div" sx={{ fontWeight: 800, lineHeight: 1, fontSize: "clamp(28px, 5vw, 64px)" }}>
          {hh}:{mm}
          <Typography component="span" sx={{ fontSize: "0.5em", ml: 1, opacity: 0.7 }}>{ss}</Typography>
        </Typography>
        <Typography component="div" sx={{ fontSize: "clamp(14px, 1.6vw, 22px)", opacity: 0.8 }}>
          {days[d.getDay()]} ¬∑ {String(d.getDate()).padStart(2, "0")}.
          {String(d.getMonth() + 1).padStart(2, "0")}.
          {d.getFullYear()}.
        </Typography>
      </Stack>
      <Stack direction="row" alignItems="center" spacing={1.5}>
        <Tooltip title={connected ? "–û–Ω–ª–∞—ò–Ω" : "–ù–µ–º–∞ –≤–µ–∑–µ"}>
          <Box>{connected ? <CloudDoneIcon fontSize="large" /> : <CloudOffIcon color="error" fontSize="large" />}</Box>
        </Tooltip>
        <Tooltip title={audioReady ? "–ó–≤—É–∫ —É–∫—ô—É—á–µ–Ω" : "–ó–≤—É–∫ —ò–µ –±–ª–æ–∫–∏—Ä–∞–Ω ‚Äî –æ–º–æ–≥—É—õ–∏"}>
          <IconButton onClick={onUnlock} size="large">
            {audioReady ? <VolumeUpIcon /> : <VolumeOffIcon color="warning" />}
          </IconButton>
        </Tooltip>
        <Tooltip title="–û—Å–≤–µ–∂–∏ –ø–æ–¥–∞—Ç–∫–µ">
          <IconButton onClick={onSoftRefresh} size="large">
            <RefreshIcon />
          </IconButton>
        </Tooltip>
      </Stack>
    </Stack>
  );
}

// =====================
// Hook: measure available space of a container
// =====================
function useMeasure() {
  const ref = useRef(null);
  const [rect, setRect] = useState({ w: 0, h: 0 });
  useEffect(() => {
    if (!ref.current) return;
    const ro = new ResizeObserver((entries) => {
      const cr = entries[0].contentRect;
      setRect({ w: cr.width, h: cr.height });
    });
    ro.observe(ref.current);
    return () => ro.disconnect();
  }, []);
  return [ref, rect];
}

// =====================
// Gigantic circular timer sized by measured box
// =====================
function HeroTimer({ startTs, endTs, now, accentColor = "primary", boxSize }) {
  if (!startTs || !endTs || !boxSize) return null;
  const start = startTs.getTime();
  const end = endTs.getTime();
  const total = Math.max(0, end - start);
  const elapsed = Math.min(Math.max(0, now - start), total);
  const remaining = Math.max(0, end - now);
  const value = total > 0 ? Math.round((elapsed / total) * 100) : 0;

  const totalSeconds = Math.floor(remaining / 1000);
  const hh = Math.floor(totalSeconds / 3600);
  const mm = Math.floor((totalSeconds % 3600) / 60);
  const ss = totalSeconds % 60;
  const timeStr = (hh > 0 ? String(hh).padStart(2, "0") + ":" : "") +
    String(mm).padStart(2, "0") + ":" + String(ss).padStart(2, "0");

  const thickness = Math.max(6, Math.round(boxSize * 0.04));

  return (
    <Box sx={{ position: "relative", width: boxSize, height: boxSize }}>
      <CircularProgress variant="determinate" value={100} thickness={Math.max(4, Math.round(thickness * 0.6))} size={boxSize} sx={{ color: "action.hover", position: "absolute", inset: 0 }} />
      <CircularProgress variant="determinate" value={value} thickness={thickness} size={boxSize} color={accentColor} sx={{ position: "absolute", inset: 0 }} />
      <Box sx={{ position: "absolute", inset: thickness + 8, display: "flex", alignItems: "center", justifyContent: "center", textAlign: "center" }}>
        <Typography sx={{ fontWeight: 800, fontSize: Math.max(56, Math.round(boxSize * 0.22)), lineHeight: 1 }}>{timeStr}</Typography>
      </Box>
    </Box>
  );
}

function MiddleCircle({ nowTick, current }) {
  const [ref, rect] = useMeasure();
  const box = Math.max(120, Math.min(rect.w, rect.h));
  return (
    <Box ref={ref} sx={{ flex: 1, minHeight: 0, width: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
      {current && box > 0 ? (
        <HeroTimer
          startTs={current.startTs}
          endTs={current.endTs}
          now={nowTick}
          accentColor={current?.type === '–ß–ê–°' ? 'error' : 'success'}
          boxSize={Math.floor(box * 0.9)}
        />
      ) : (
        <Typography sx={{ fontWeight: 800, fontSize: 'clamp(56px, 12vw, 200px)' }}>‚Äî:‚Äî</Typography>
      )}
    </Box>
  );
}

export default function DisplayBoard() {
  const [today, setToday] = useState(null);
  const [nextBell, setNextBell] = useState(null);
  const [nowTick, setNowTick] = useState(Date.now());
  const [announcements, setAnnouncements] = useState([]);
  const [overrideAnnouncement, setOverrideAnnouncement] = useState(null);
  const [connected, setConnected] = useState(false);
  const [audioReady, setAudioReady] = useState(false);
  const socketRef = useRef(null);
  const audioRef = useRef(null);

  // Audio init & unlock
  useEffect(() => {
    const audio = new Audio(alertSound);
    audio.volume = 1.0;
    audioRef.current = audio;
    const warm = new Audio(alertSound);
    warm.volume = 0;
    warm.play().then(() => { warm.pause(); warm.currentTime = 0; }).catch(() => { });
    const tryUnlockOnce = async () => {
      try { await audio.play(); audio.pause(); audio.currentTime = 0; setAudioReady(true); window.removeEventListener("pointerdown", tryUnlockOnce); window.removeEventListener("keydown", tryUnlockOnce); } catch { }
    };
    window.addEventListener("pointerdown", tryUnlockOnce, { once: true });
    window.addEventListener("keydown", tryUnlockOnce, { once: true });
    return () => { window.removeEventListener("pointerdown", tryUnlockOnce); window.removeEventListener("keydown", tryUnlockOnce); };
  }, []);

  const unlockAudio = async () => {
    if (!audioRef.current) return;
    try { await audioRef.current.play(); audioRef.current.pause(); audioRef.current.currentTime = 0; setAudioReady(true); } catch (e) { console.warn('Audio unlock failed:', e); }
  };
  const playAlertSound = () => {
    if (!audioRef.current || !audioReady) return;
    try { audioRef.current.pause(); audioRef.current.currentTime = 0; audioRef.current.play().catch(() => { }); } catch { }
  };

  // ‚úÖ API fetch za aktivna obave≈°tenja
  const fetchActiveAnnouncements = async () => {
    try {
      const res = await api.get("/announcements/active");
      setAnnouncements(res.data.items || []);
    } catch (e) {
      console.warn("–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —É—á–∏—Ç–∞–≤–∞—ö—É –æ–±–∞–≤–µ—à—Ç–µ—ö–∞", e);
    }
  };
  useEffect(() => { fetchActiveAnnouncements(); }, []);

  const softRefresh = async () => {
    const [t, n] = await Promise.all([bellApi.getToday(), bellApi.getNext()]);
    setToday(t);
    setNextBell(n);
    fetchActiveAnnouncements();
  };
  useEffect(() => { softRefresh(); }, []);

  useEffect(() => {
    const t = setInterval(() => setNowTick(Date.now()), 1000);
    return () => clearInterval(t);
  }, []);

  // Socket
  useEffect(() => {
    const url = import.meta.env.VITE_WS_BASE || "http://localhost:3000";
    const s = io(url, { transports: ["websocket"] });
    socketRef.current = s;
    const refetchActive = () => fetchActiveAnnouncements();
    s.on("connect", () => setConnected(true));
    s.on("disconnect", () => setConnected(false));
    s.on("bell:next", (payload) => setNextBell(payload));
    s.on("announcement:created", refetchActive);
    s.on("announcement:updated", refetchActive);
    s.on("announcement:deleted", refetchActive);
    s.on("announcement:push", (data) => {
      setOverrideAnnouncement(data);
      playAlertSound();
      setTimeout(() => setOverrideAnnouncement(null), 60000);
    });
    return () => { s.disconnect(); };
  }, [audioReady]);

  // Derived timings
  const rings = useMemo(() => buildRings(today?.json_spec), [today]);
  const segments = useMemo(() => buildSegments(rings), [rings]);
  const current = useMemo(() => {
    const now = new Date(nowTick);
    for (const seg of segments) { if (now >= seg.startTs && now < seg.endTs) return seg; }
    return null;
  }, [segments, nowTick]);

  const nextTs = nextBell?.ts ? new Date(nextBell.ts) : null;
  const countdownMs = useMemo(() => (nextTs ? nextTs.getTime() - nowTick : 0), [nextTs, nowTick]);
  const isHoliday = Boolean(today?.is_holiday);

  return (
    <Box sx={{ height: "100dvh", display: "flex", flexDirection: "column", bgcolor: "background.default", color: "text.primary", overflow: "hidden" }}>
      <TopBar nowTick={nowTick} connected={connected} audioReady={audioReady} onUnlock={unlockAudio} onSoftRefresh={softRefresh} />

      {/* Announcements (does not shrink main area) */}
      <Box sx={{ flexShrink: 0 }}>
        <CarouselAnnouncementBoard items={announcements} override={overrideAnnouncement} />
      </Box>

      {/* Main content */}
      <Box sx={{ flex: 1, minHeight: 0, px: 3, pb: 3, display: "flex", alignItems: "stretch", justifyContent: "center" }}>
        {isHoliday ? (
          <Typography sx={{ fontSize: "clamp(40px, 8vw, 120px)", fontWeight: 800, textAlign: "center" }}>–î–∞–Ω–∞—Å —ò–µ –Ω–µ—Ä–∞–¥–Ω–∏ –¥–∞–Ω</Typography>
        ) : (
          <Stack spacing={2} alignItems="center" sx={{ flex: 1, minHeight: 0, width: "100%" }}>
            <Chip label={
              current?.type === "–ß–ê–°"
                ? `${current?.periodNo ?? "?"}. –ß–ê–°`
                : current?.type || "–í–∞–Ω —Ä–∞—Å–ø–æ—Ä–µ–¥–∞"
            } color={current?.type === "–ß–ê–°" ? "error" : "success"} sx={{ fontSize: "clamp(14px, 2vw, 24px)", px: 2.5, py: 2, borderRadius: 3 }} />
            <MiddleCircle nowTick={nowTick} current={current} />
            <Typography sx={{ fontSize: "clamp(16px, 2vw, 24px)" }}>
              –°–ª–µ–¥–µ—õ–µ –∑–≤–æ–Ω–æ —É {nextTs ? formatClock(nextTs) : "‚Äî"} {nextBell?.label && (<Box component="span" sx={{ textTransform: "lowercase", ml: 1 }}>({nextBell.label})</Box>)}
            </Typography>
            {!current && (
              <>
                <Typography sx={{ fontSize: "clamp(18px, 3vw, 32px)", opacity: 0.8 }}>
                  {countdownMs > 0 ? "–°–ª–µ–¥–∏ —Å–ª–µ–¥–µ—õ–µ –∑–≤–æ–Ω–æ" : "–ù–µ–º–∞ –∞–∫—Ç–∏–≤–Ω–∏—Ö –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞"}
                </Typography>
                <Typography sx={{ fontWeight: 800, fontSize: "clamp(56px, 12vw, 200px)" }}>
                  {countdownMs > 0 ? formatMS(countdownMs) : "--:--"}
                </Typography>
              </>
            )}
          </Stack>
        )}
      </Box>
    </Box>
  );
}


// File: /var/www/html/pametna-skola2/frontend/src/components/DisplayBoard/MiniSchedule.jsx
/**
 * File: MiniSchedule.jsx
 * Path: /frontend/src/components/DisplayBoard
 * Author: Sa≈°a Kojadinoviƒá
 */

import { useMemo } from "react";
import {
  Box,
  Typography,
  List,
  ListItem,
  ListItemText,
  Chip,
  Divider,
} from "@mui/material";
import { formatClock } from "../../utils/bell";

/**
 * Prikaz liste zvona za –¥–∞–Ω–∞—Å sa isticanjem:
 *  - —Ç–µ–∫—É—õ–µ–≥ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ (–æ–∑–Ω–∞—á–µ–Ω–æ–≥ –ø—Ä–µ–∫–æ segments)
 *  - —Å–ª–µ–¥–µ—õ–µ–≥ –∑–≤–æ–Ω–∞ (nextTs)
 *
 * Props:
 *  - rings: [{ ts: Date, label: string }]
 *  - segments: [{ startTs, endTs, type, periodNo, ... }]
 *  - now: number (Date.now())
 *  - nextTs: Date | null
 */
export default function MiniSchedule({ rings = [], segments = [], now, nextTs }) {
  const nowDate = useMemo(() => new Date(now), [now]);

  // Pronaƒëi aktivan segment, da bismo istakli zvona koja ga omeƒëuju
  const activeSeg = useMemo(() => {
    for (const s of segments) {
      if (nowDate >= s.startTs && nowDate < s.endTs) return s;
    }
    return null;
  }, [segments, nowDate]);

  // Mapiramo svako zvono sa metapodacima za isticanje
  const items = useMemo(() => {
    return rings.map((r, idx) => {
      const isStartOfActive =
        activeSeg && +r.ts === +activeSeg.startTs; // +Date ‚Üí timestamp broj
      const isEndOfActive =
        activeSeg && idx > 0 && +r.ts === +activeSeg.endTs;
      const isNext = nextTs && +r.ts === +nextTs;

      let secondary = r.label || "";
      if (isStartOfActive && activeSeg?.type === "–ß–ê–°") {
        secondary = `–ü–æ—á–µ—Ç–∞–∫ —á–∞—Å–∞ ${activeSeg.periodNo}${
          r.label ? ` ‚Äì ${r.label}` : ""
        }`;
      } else if (isStartOfActive && activeSeg?.type === "–û–î–ú–û–†") {
        secondary = `–ü–æ—á–µ—Ç–∞–∫ –æ–¥–º–æ—Ä–∞${r.label ? ` ‚Äì ${r.label}` : ""}`;
      } else if (isEndOfActive && activeSeg?.type === "–ß–ê–°") {
        secondary = `–ö—Ä–∞—ò —á–∞—Å–∞ ${activeSeg.periodNo}${
          r.label ? ` ‚Äì ${r.label}` : ""
        }`;
      } else if (isEndOfActive && activeSeg?.type === "–û–î–ú–û–†") {
        secondary = `–ö—Ä–∞—ò –æ–¥–º–æ—Ä–∞${r.label ? ` ‚Äì ${r.label}` : ""}`;
      }

      return {
        key: idx,
        time: formatClock(r.ts),
        primary: secondary || "‚Äî",
        isNext,
        isBoundary: isStartOfActive || isEndOfActive,
      };
    });
  }, [rings, activeSeg, nextTs]);

  if (!rings.length) return null;

  return (
    <Box sx={{ mt: 3, textAlign: "left" }}>
      <Typography variant="h5" sx={{ mb: 1 }}>
        –î–∞–Ω–∞—à—ö–∏ —Ä–∞—Å–ø–æ—Ä–µ–¥
      </Typography>
      <List disablePadding>
        {items.map((it, i) => (
          <Box key={it.key}>
            <ListItem
              sx={{
                py: 1,
                borderRadius: 2,
                bgcolor: it.isBoundary ? "action.hover" : "transparent",
              }}
              secondaryAction={
                it.isNext ? <Chip label="–°–ª–µ–¥–µ—õ–µ" color="primary" size="small" /> : null
              }
            >
              <ListItemText
                primaryTypographyProps={{
                  variant: "body1",
                  sx: { fontWeight: it.isBoundary ? 600 : 400 },
                }}
                secondaryTypographyProps={{ variant: "body2" }}
                primary={`${it.time}`}
                secondary={it.primary}
              />
            </ListItem>
            {i < items.length - 1 && <Divider component="li" />}
          </Box>
        ))}
      </List>
    </Box>
  );
}


// File: /var/www/html/pametna-skola2/frontend/src/components/DisplayBoard/ProgressTimer.jsx
/**
 * File: ProgressTimer.jsx
 * Path: /frontend/src/components/DisplayBoard
 * Author: Sa≈°a Kojadinoviƒá
 */

import { Box, LinearProgress, Typography } from "@mui/material";

/**
 * Prikazuje preostalo vreme i napredak unutar tekuƒáeg intervala.
 * Props:
 *  - startTs: Date
 *  - endTs: Date
 *  - now: number (Date.now())
 *  - label: string (–Ω–ø—Ä. "–ß–∞—Å 3" ili "–û–¥–º–æ—Ä")
 */
export default function ProgressTimer({ startTs, endTs, now, label }) {
  if (!startTs || !endTs) return null;

  const start = startTs.getTime();
  const end = endTs.getTime();
  const total = Math.max(0, end - start);
  const elapsed = Math.min(Math.max(0, now - start), total);
  const remaining = Math.max(0, end - now);

  const value = total > 0 ? Math.round((elapsed / total) * 100) : 0;

  // ‚á© HH:MM:SS format
  const totalSeconds = Math.floor(remaining / 1000);
  const hh = Math.floor(totalSeconds / 3600);
  const mm = Math.floor((totalSeconds % 3600) / 60);
  const ss = totalSeconds % 60;

  return (
    <Box sx={{ width: "100%", textAlign: "center" }}>
      <Typography variant="h6" sx={{ mb: 0.5 }}>
        {label? label.type === "–ß–ê–°"
                      ? "–ü—Ä–µ–æ—Å—Ç–∞–ª–æ –≤—Ä–µ–º–µ –¥–æ –∫—Ä–∞—ò–∞ —á–∞—Å–∞"
                      : "–ü—Ä–µ–æ—Å—Ç–∞–ª–æ –≤—Ä–µ–º–µ –¥–æ –∫—Ä–∞—ò–∞ –æ–¥–º–æ—Ä–∞"
                    : "–í–∞–Ω —à–∫–æ–ª—Å–∫–æ–≥ —Ä–∞—Å–ø–æ—Ä–µ–¥–∞"}
       
      </Typography>
      <Typography variant="h1" sx={{ fontWeight: 800, mb: 1 }}>
        {String(hh).padStart(2, "0")}:
        {String(mm).padStart(2, "0")}:
        {String(ss).padStart(2, "0")}
      </Typography>
      <LinearProgress
        color={label?.type === "–ß–ê–°" ? "error" : "success"}
        variant="determinate"
        value={value}
        sx={{ height: 10, borderRadius: 2 }}
      />
    </Box>
  );
}



// File: /var/www/html/pametna-skola2/frontend/src/context/GlobalContext.jsx


// File: /var/www/html/pametna-skola2/frontend/src/main.jsx
/**
 * File: main.jsx
 * Path: /frontend/src
 * Author: Sa≈°a Kojadinoviƒá
 */
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./App.jsx";
import './main.css';

import { LocalizationProvider } from "@mui/x-date-pickers";
import { AdapterDayjs } from "@mui/x-date-pickers/AdapterDayjs";
import "dayjs/locale/sr";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <LocalizationProvider dateAdapter={AdapterDayjs} adapterLocale="sr">
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </LocalizationProvider>
  </React.StrictMode>
);


// File: /var/www/html/pametna-skola2/frontend/src/pages/AdminPage.jsx
/**
 * File: AdminPage.jsx
 * Path: /frontend/src/pages
 * Author: Sa≈°a Kojadinoviƒá
 */

import { useState } from "react";
import { Box, Tabs, Tab } from "@mui/material";
import BellTemplatesPage from "../components/Admin/BellTemplatesPage";
import DayScheduleCalendar from "../components/Admin/DayScheduleCalendar";
import AdminAnnouncements from "../components/Admin/AdminAnnouncements"; // ‚¨ÖÔ∏è dodaj ovo

export default function AdminPage() {
  const [tab, setTab] = useState(0);

  return (
    <Box sx={{ p: 2 }}>
      <Tabs value={tab} onChange={(_, v) => setTab(v)} sx={{ mb: 2 }}>
        <Tab label="–®–∞–±–ª–æ–Ω–∏" />
        <Tab label="–ö–∞–ª–µ–Ω–¥–∞—Ä" />
        <Tab label="–û–±–∞–≤–µ—à—Ç–µ—ö–∞" /> {/* ‚¨ÖÔ∏è novi tab */}
      </Tabs>

      {tab === 0 && <BellTemplatesPage />}
      {tab === 1 && <DayScheduleCalendar />}
      {tab === 2 && <AdminAnnouncements />} {/* ‚¨ÖÔ∏è nova komponenta */}
    </Box>
  );
}


// File: /var/www/html/pametna-skola2/frontend/src/pages/MonitorPage.jsx
/**
 * File: MonitorPage.jsx
 * Path: /frontend/src/pages
 * Author: Sa≈°a Kojadinoviƒá
 */
import DisplayBoard from '../components/DisplayBoard/DisplayBoard'

export default function MonitorPage() {
  return <DisplayBoard />
}


// File: /var/www/html/pametna-skola2/frontend/src/theme/muiTheme.js
/**
 * File: muiTheme.js
 * Path: /frontend/src/theme
 * Author: Sa≈°a Kojadinoviƒá
 */
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    mode: "light",
    // ‚úÖ redefinisana primary paleta
    primary: {
      main: '#36383a',      // tamno siva
      light: '#676c70',     // svetlija siva
      dark: '#0e0e0e',      // skoro crna
      contrastText: '#fff', // bela slova na tamnoj pozadini
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: "uppercase", 
        },
      },
    },
  },
});

export default theme;


// File: /var/www/html/pametna-skola2/frontend/src/utils/bell.js
/**
 * File: bell.js
 * Path: /frontend/src/utils
 * Author: Sa≈°a Kojadinoviƒá
 */

// "HH:MM" -> Date za dana≈°nji dan (lokalno)
export function timeToday(hhmm) {
  const [h, m] = String(hhmm || "").split(":").map((x) => parseInt(x, 10));
  const now = new Date();
  const d = new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate(),
    isFinite(h) ? h : 0,
    isFinite(m) ? m : 0,
    0,
    0
  );
  return d;
}

// Iz json_spec pravi listu zvona [{ ts: Date, label: string }]
export function buildRings(json_spec) {
  let spec;
  try {
    spec = typeof json_spec === "string" ? JSON.parse(json_spec) : json_spec;
  } catch {
    return [];
  }
  const rings = Array.isArray(spec?.rings) ? spec.rings : [];
  return rings
    .map((r) => ({ ts: timeToday(r.time), label: r.label || "" }))
    .filter((r) => !Number.isNaN(r.ts?.getTime()))
    .sort((a, b) => a.ts - b.ts);
}

// Poku≈°aj da izvuƒçe≈° redni broj ƒçasa iz labele ("–ü–æ—á–µ—Ç–∞–∫ 3.", "–ö—Ä–∞—ò 2."...)
export function parsePeriodNumber(txt) {
  const m = String(txt || "").match(/(\d+)/);
  return m ? parseInt(m[1], 10) : null;
}

/**
 * Iz zvona pravi segmente (intervale) dana:
 *  [
 *    {
 *      startTs: Date,
 *      endTs: Date,
 *      type: "–ß–ê–°" | "–û–î–ú–û–†",
 *      periodNo: number,
 *      startLabel: string,
 *      endLabel: string
 *    }, ...
 *  ]
 *
 * Heuristika:
 * - Ako labela startnog zvona ukljuƒçuje "–∫—Ä–∞—ò/kraj/end" -> segment je –û–î–ú–û–†
 * - U suprotnom -> –ß–ê–°
 * - Ako nema dovoljno informacija, alternira: prvi segment tretira kao –ß–ê–°
 * - Broj ƒçasa: poku≈°ava iz labela; fallback je Math.floor(i/2)+1
 */
export function buildSegments(rings) {
  if (!Array.isArray(rings) || rings.length < 2) return [];
  const segments = [];

  for (let i = 0; i < rings.length - 1; i++) {
    const start = rings[i];
    const end = rings[i + 1];
    const startLbl = (start.label || "").toLowerCase();

    const isBreakExplicit =
      startLbl.includes("–∫—Ä–∞—ò") || startLbl.includes("kraj") || startLbl.includes("end");

    const altIsBreak = i % 2 === 1; // 0: ƒças, 1: odmor, 2: ƒças, ...
    const isBreak = isBreakExplicit ? true : altIsBreak;

    const pNum =
      parsePeriodNumber(start.label) ??
      parsePeriodNumber(end.label) ??
      Math.floor(i / 2) + 1;

    segments.push({
      startTs: start.ts,
      endTs: end.ts,
      type: isBreak ? "–û–î–ú–û–†" : "–ß–ê–°",
      periodNo: pNum,
      startLabel: start.label || "",
      endLabel: end.label || "",
    });
  }

  return segments;
}

// Format pomoƒánici
export const pad2 = (n) => String(n).padStart(2, "0");

export function formatClock(ts) {
  if (!ts) return "";
  return new Date(ts).toLocaleTimeString("sr-RS", { hour: "2-digit", minute: "2-digit" });
}

export function formatHMS(ms) {
  const total = Math.max(0, Math.floor(ms / 1000));
  const h = Math.floor(total / 3600);
  const m = Math.floor((total % 3600) / 60);
  const s = total % 60;
  return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
}

export function formatMS(ms) {
  const total = Math.max(0, Math.floor(ms / 1000));
  const m = Math.floor(total / 60);
  const s = total % 60;
  return `${pad2(m)}:${pad2(s)}`;
}


